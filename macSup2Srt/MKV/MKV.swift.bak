//
//  MKV.swift
//  macSup2Srt
//
//  Created by Ethan Dye on 9/13/24.
//  Copyright Â© 2024 Ethan Dye. All rights reserved.
//

import Foundation

extension Data {
    // Function to remove null bytes (0x00) from Data
    mutating func removeNullBytes() {
        let nullByte: UInt8 = 0x00
        // Find the range of null bytes and remove them
        self.removeAll { $0 == nullByte }
    }
}

// MARK: - Struct to Represent MKV Tracks

struct MKVTrack {
    let trackNumber: Int
    let trackType: UInt8
    let codecId: String
}

// MARK: - Main MKV Parser


class MKVParser {
    private var fileHandle: FileHandle?
    private var eof: UInt64?
    
    // Open the MKV file
    func openFile(filePath: String) -> Bool {
        guard FileManager.default.fileExists(atPath: filePath) else {
            print("File does not exist")
            return false
        }
        
        do {
            self.fileHandle = try FileHandle(forReadingFrom: URL(fileURLWithPath: filePath))
            self.eof = fileHandle!.seekToEndOfFile()
            fileHandle!.seek(toFileOffset: 0)
            seekToFirstSubtitleTrack()
            print("MKV file opened successfully")
            return true
        } catch {
            print("Error opening file: \(error)")
            return false
        }
    }
    
    // Close the MKV file
    func closeFile() {
        fileHandle?.closeFile()
        fileHandle = nil
    }
    
    // Parse the EBML structure and find the Tracks section
    func parseTracks() -> [MKVTrack]? {
//        guard let fileHandle = fileHandle else {
//            print("File not opened")
//            return nil
//        }
        
        // Step 1: Search for the Segment element
        guard findElement(withID: EBML.segmentID) else {
            print("Segment element not found")
            return nil
        }
        
        // Step 2: Search for the Tracks element within the Segment
        guard findElement(withID: EBML.tracksID) else {
            print("Tracks element not found")
            return nil
        }
        
        // Step 3: Parse all TrackEntry elements within the Tracks section
        var trackList = [MKVTrack]()
        while let (elementID, elementSize, _) = tryParseElement() {
            if elementID == EBML.trackEntryID {
                print("another track")
                if let track = parseTrackEntry() {
                    trackList.append(track)
                }
            } else if elementID == EBML.chapters {
                break  // We've got them all
            } else {
                print("skipping: \(elementID) \(elementSize)")
                fileHandle?.seek(toFileOffset: fileHandle!.offsetInFile + elementSize)
            }
            
        }
        
        return trackList
    }
    
    // Function to find a specific EBML element by its ID
    private func findElement(withID targetID: UInt32) -> Bool {
        guard let fileHandle = self.fileHandle else { return false }
        
        while let (elementID, elementSize, _) = tryParseElement() {
            print(String(format:"targetID: 0x%08X", targetID))
            print(String(format:"recvdID: 0x%08X", elementID))
            if elementID == targetID {
                return true
            } else {
                // Skip over the element's data
                fileHandle.seek(toFileOffset: fileHandle.offsetInFile + elementSize)
            }
        }
        
        return false
    }
    
    // Try parsing an EBML element, returning its ID and size (or nil if EOF)
    private func tryParseElement(unmodified: Bool = false) -> (elementID: UInt32, elementSize: UInt64, os: UInt64)? {
        guard let fileHandle = self.fileHandle, fileHandle.offsetInFile < eof!  else {
            return nil
        }
        let oldOs = fileHandle.offsetInFile
        
        let (elementID, elementSize) = readEBMLElement(from: fileHandle, unmodified: unmodified)
        return (elementID, elementSize, os: oldOs)
    }
    
    // Parse a TrackEntry element and return an MKVTrack object
    private func parseTrackEntry() -> MKVTrack? {
        guard let fileHandle = self.fileHandle else { return nil }
        
        var trackNumber: Int?
        var trackType: UInt8?
        var codecId: String?
        
        // Parse through the elements within the TrackEntry
        while let (elementID, elementSize, _) = tryParseElement() {
            switch elementID {
            case EBML.trackNumberID:
                trackNumber = Int((readBytes(from: fileHandle, length: 1)?.first)!) //Int(readVINT(from: fileHandle, unmodified: true))
                print("trackNumber: \(trackNumber!)")
            case EBML.trackUID, EBML.flagDefault, EBML.flagLacing, 0x6DE7:
                fileHandle.seek(toFileOffset: fileHandle.offsetInFile + 1)
            case EBML.trackTypeID:
                trackType = readBytes(from: fileHandle, length: Int(1))?.first
                print("trackType: \(trackType!)")
            case EBML.codecID:
                var data = readBytes(from: fileHandle, length: Int(elementSize))
                data?.removeNullBytes()
                if data!.count > 0 {
                    codecId = String(data: data!, encoding: .ascii)
                } else {
                    print("fail")
                }
                print("\(data! as NSData)")
                print("codec: \(codecId!)")
            default:
                // Skip over other elements
                print("skipping")
                fileHandle.seek(toFileOffset: fileHandle.offsetInFile + elementSize)
            }
            
            // Exit early if we have found all necessary info
            if trackNumber != nil, trackType != nil, codecId != nil {
                break
            }
        }
        
        // Return the parsed track entry
        if let trackNumber = trackNumber, let trackType = trackType, let codecId = codecId {
            return MKVTrack(trackNumber: trackNumber, trackType: trackType, codecId: codecId)
        }
        
        return nil
    }
    
    // Seek to the first subtitle track
    func seekToFirstSubtitleTrack() {
        guard let trackList = parseTracks() else {
            print("No tracks found")
            return
        }
        
        // Find the first subtitle track
        if let subtitleTrack = trackList.first(where: { $0.trackType == EBML.subtitleTrackType }) {
            print("Found subtitle track: \(subtitleTrack.trackNumber), Codec: \(subtitleTrack.codecId)")
            if let trackData = seekToTrackData(trackNumber: subtitleTrack.trackNumber) {
                print("Found track data for track number \(subtitleTrack.trackNumber): \(trackData)")
            } else {
                print("Failed to find track data for track number \(subtitleTrack.trackNumber).")
            }
            // Normally you would seek to the actual subtitle data here
        } else {
            print("No subtitle track found")
        }
    }
    
    // Function to find an EBML element with a specific ID
    func findElement(withID targetID: UInt32, _ tgtID2: UInt32? = nil) -> UInt64? {
        guard let fileHandle = self.fileHandle else { return nil }
        while let (elementID, elementSize, _) = tryParseElement() {
            if fileHandle.offsetInFile >= eof! {
                            return nil
            }
            print(String(format:"targetID: 0x%08X", targetID))
            print(String(format:"recvdID: 0x%08X", elementID))
            if elementID == targetID || (tgtID2 != nil && elementID == tgtID2!){
                print("gotitB")
                return elementSize
            } else {
                // Skip over the element's data
                fileHandle.seek(toFileOffset: fileHandle.offsetInFile + elementSize)
            }
        }
        return nil
//        while true {
//            let (currentElementID, elementSize) = readEBMLElement(from: fileHandle)
//            
//            if currentElementID == elementID {
//                return elementSize
//            }
//            
//            fileHandle.seek(toFileOffset: fileHandle.offsetInFile + elementSize)
//            
//            if fileHandle.offsetInFile >= fileHandle.seekToEndOfFile() {
//                return nil
//            }
//        }
    }
    
    
    // Function to seek to the track bytestream for a specific track number
    func seekToTrackData(trackNumber: Int) -> Data? {
        guard let fileHandle = self.fileHandle else { return nil }
        fileHandle.seek(toFileOffset: 0)
        // Step 1: Locate the Segment element
        if let segmentSize = findElement(withID: EBML.segmentID) {
            let segmentEndOffset = fileHandle.offsetInFile + segmentSize
            
            // Step 2: Parse Clusters within the Segment
            while fileHandle.offsetInFile < segmentEndOffset {
                if let clusterSize = findElement(withID: EBML.cluster) {
                    let clusterEndOffset = fileHandle.offsetInFile + clusterSize
                    
                    // Step 3: Parse Blocks (SimpleBlock or Block) within each Cluster
                    while fileHandle.offsetInFile < eof! {
                        if let blockSize = findElement(withID: EBML.simpleBlock, EBML.block) {
                            let blockStartOffset = fileHandle.offsetInFile
                            
                            // Step 4: Read the first byte to get the track number
                            if let blockTrackNumber = readTrackNumber(from: fileHandle) {
                                print("Found Block for Track \(blockTrackNumber)")
                                if blockTrackNumber == trackNumber {
                                    // Step 5: Read the block data
                                    let blockData = fileHandle.readData(ofLength: Int(blockSize - (fileHandle.offsetInFile - blockStartOffset)))
                                    return blockData
                                } else {
                                    // Skip this block, it's for a different track
                                    fileHandle.seek(toFileOffset: fileHandle.offsetInFile + (blockSize - (fileHandle.offsetInFile - blockStartOffset)))
                                }
                            }
                        } else {
                            break // No more blocks found in this cluster
                        }
                    }
                } else {
                    break // No more clusters found in the segment
                }
            }
        }
        
        return nil
    }

    // Function to read the track number from a SimpleBlock or Block element
    func readTrackNumber(from fileHandle: FileHandle) -> UInt64? {
        // SimpleBlock/Block structure starts with a VINT that encodes the track number
        return UInt64((readBytes(from: fileHandle, length: 1)?.first)! & (0x80 - 1)) // readVINT(from: fileHandle, unmodified: true)
    }
}

// MARK: - Usage Example
//
//let mkvParser = MKVParser()
//let filePath = "/path/to/your/file.mkv" // Replace with your MKV file path
//
//if mkvParser.openFile(filePath: filePath) {
//    mkvParser.seekToFirstSubtitleTrack()
//    mkvParser.closeFile()
//} else {
//    print("Failed to open the MKV file.")
//}
